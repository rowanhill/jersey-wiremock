{
  "name": "Jersey-wiremock",
  "tagline": "Easily create simple WireMock stubbers/verifiers based on Jersey resources",
  "body": "# jersey-wiremock\r\nAutogenerated stubbing & verifying of Jersey resources with WireMock\r\n\r\n## What is it?\r\nJersey (particularly as part of Dropwizard) is great for developing HTTP APIs, using declarative annotations to define\r\nbehaviour.\r\n\r\nWireMock is great at mocking out HTTP APIs when writing integration tests.\r\n\r\nWith jersey-wiremock, you can create classes which encapsulate the logic of mocking out your resources (e.g. building\r\npaths, adding query parameters, serialising response entities) without having to write all the boilerplate.\r\n\r\n## Show me an example\r\n\r\nLet's say you have the following resource:\r\n\r\n```java\r\n@Path(\"/cakes\")\r\n@Produces(MediaType.APPLICATION_JSON)\r\npublic class CakesResource {\r\n    @GET\r\n    public List<Cake> getAllCakesByFlavour(@QueryParam(\"flavour\") CakeFlavour flavour) {\r\n        // ... retrieve all cakes with given flavour from data store and return result\r\n    }\r\n\r\n    @POST\r\n    public long addNewCake(Cake cake) {\r\n        // ... add cake to data store and return assigned id ...\r\n    }\r\n}\r\n```\r\n\r\nUsing jersey-wiremock, you can define a mocker like this:\r\n\r\n```java\r\n@WireMockForResource(CakesResource.class)\r\npublic interface CakesMocker {\r\n    @WireMockStub(\"getAllCakesByFlavour\")\r\n    GetListRequestStubber<Cake> stubGetAllCakesByFlavour(CakeFlavour flavour);\r\n    @WireMockVerify(\"getAllCakesByFlavour\")\r\n    GetRequestVerifier verifyGetAllCakesByFlavour(CakeFlavour flavour);\r\n\r\n    @WireMockStub(\"addNewCake\")\r\n    PostRequestVerifier<Void> stubAddCake();\r\n}\r\n```\r\n\r\nWhich you can then use in your tests like this:\r\n\r\n```java\r\npublic class OtherServiceIntegrationTest {\r\n    // ... set up an OtherService instance somehow - perhaps via DropwizardAppRule ...\r\n\r\n    @Rule\r\n    public WireMockRule wireMockRule = new WireMockRule(8080);\r\n\r\n    private CakesMocker cakesMocker;\r\n\r\n    @Before\r\n    public void setUp() {\r\n        ObjectMapper objectMapper = new ObjectMapper();\r\n        cakesMocker = MockerFactory.wireMockerFor(\r\n            CakesMocker.class, wireMockRule, objectMapper);\r\n    }\r\n\r\n    @Test\r\n    public void otherServiceRequestsCakesByFlavourExactlyOnce() {\r\n        // given\r\n        CakeFlavour flavour = CakeFlavour.CHOCOLATE;\r\n        cakesMocker.stubGetAllCakesByFlavour(flavour)\r\n            .andRespondWith(new Cake(1, flavour, \"Test recipe\")).stub();\r\n\r\n        // when\r\n        // ... invoke something on OtherService instance ...\r\n\r\n        // then\r\n        // ... maybe make some assertions ...\r\n        cakesMocker.verifyGetAllCakesbyFlavour(flavour).times(1).verify();\r\n    }\r\n\r\n    @Test\r\n    public void otherServiceHandlesErrorWhenCreatingCake() {\r\n        // given\r\n        cakesMocker.stubAddCake()\r\n                .withRequestBody(matchingJsonPath(\r\n                    \"$..[?(@.status=='\" + CakeFlavour.LEMON + \"')]\"\r\n                ))\r\n                .andRespond().withStatusCode(500).stub();\r\n\r\n        // when\r\n        // ... invoke something on OtherService instance that creates a lemon cake ...\r\n\r\n        // then\r\n        // ... assert that OtherService gracefully handled a 500 ...\r\n    }\r\n}\r\n```\r\n\r\n## Tell me more - what can it do?\r\n\r\n### Supported operations\r\n\r\nYou can both stub and verify @GET, @POST, @PUT and @DELETE requests, using functionality automatically generated from\r\nsimple interface definitions.\r\n\r\n| Request type | Action | Interface method return type | Interface method annotation |\r\n|--------------|--------|------------------------------|-----------------------------|\r\n| `@GET` (singular return type) | Stub | `GetSingleRequestStubber<EntityType>` | `@WireMockStub` |\r\n| `@GET` (collection return type) | Stub | `GetListRequestStubber<CollectionEntityType>` | `@WireMockStub` |\r\n| `@GET` (all types) | Verify | `GetRequestVerifier` | `@WireMockVerify` |\r\n| `@POST` | Stub | `PostRequestStubber<RequestEntity, ResponseEntity>` | `@WireMockStub` |\r\n| `@POST` | Verify | `PostRequestVerifier<RequestEntity>` | `@WireMockVerify` |\r\n| `@PUT` | Stub | `PutRequestStubber<RequestEntity, ResponseEntity>` | `@WireMockStub` |\r\n| `@PUT` | Verify | `GutRequestVerifier<RequestEntity>` | `@WireMockVerify` |\r\n| `@DELETE` | Stub | `DeleteRequestStubber<ResponseEntity>` | `@WireMockStub` |\r\n| `@DELETE` | Verify | `DeleteRequestVerifier` | `@WireMockVerify` |\r\n\r\n### Argument handling\r\n#### Argument resolution\r\nArguments to mocker methods are matched up to the arguments of resource methods in one of two ways: either explicitly,\r\nusing `@ParamNamed` on every mocker method argument, or implicitly, with no arguments annotated with `@ParamNamed`.\r\n\r\nWhen resolving arguments explicitly, the mocker method must have an argument for every `@PathParam` declared by the\r\nresource method, but `@QueryParam` arguments are optional. Ordering or arguments can be arbitrary.\r\n\r\nWhen resolving arguments implicitly, the mocker interface methods must have an argument for each `@PathParam` and\r\n`@QueryParam` declared by the resource method, and they must be declared in the same order.\r\n\r\nNo other parameters (e.g. `@Context`, entity parameters) should be declared in the mocker method; `@HeaderParam` is\r\nnot supported.\r\n\r\n#### Argument serialisation\r\nIf an argument needs more careful serialisation than simply calling toString() on it, apply the `@ParamFormat`\r\nannotation to specify a `ParamFormatter` class to perform the formatting. You can do this on either the _resource_\r\nmethod argument (if you want to set a default serialiser that all mocker methods will use), or on the _mocker_ method\r\nargument (if you want to override a deafult, or if you don't want or are unable to modify the resource class).\r\n\r\n#### Query parameter matching\r\nBy default, query parameters are matched using WireMock's `equalTo()` value matching strategy. To use a different\r\nstrategy annotate the _mocker_ method parameter with `@ParamMatchedBy`. Supported strategies are `EQUAL_TO`,\r\n`CONTAINING`, `MATCHING` and `NOT_MATCHING`.\r\n\r\nNote that `@ParamMatchedBy` has no effect on path parameters.\r\n\r\n### Request body matching\r\nRequest stubbers and verifiers for request types that have request entity bodies come with two methods for matching\r\nthose request bodies: `withRequestEntity(T entity)` and `withRequestBody(ValueMatchingStrategy strategy)`. The first is\r\nwill take an entity and serialise it with the ObjectMapper to provide the string to match against. The second allows\r\nmuch more fine-grained control over the matching, by allowing specification of any WireMock `ValueMatchingStrategy`,\r\ne.g. `contains()` or `matchesJsonPath()`.\r\n\r\nIf no request body matching is specified, any request body is acceptable.\r\n\r\n### Response body writing\r\nRequest stubbers for request types that have singular response bodies can specify a response to reply with - to do so,\r\nuse either the `.andRespondWith(myEntity)` or `.andRespond().withEntity(myEntity)` forms. The given object will be\r\nserialised with the ObjectMapper and returned.\r\n\r\nFor collection type responses, usage is very similar: `.andRespondWith(entity1, entity2, ...)` or\r\n`.andRespond().withEntities(entity1, entity2)`. All entities will be placed in an empty collection of the appropriate\r\ntype, then that collection will be serialised.\r\n\r\n### Simulating faults\r\nWireMock faults can be applied to responses, e.g. `.andRespond().withFault(Fault.EMPTY_RESPONSE)`.\r\n\r\n## But it doesn't do X!\r\nThe aim is only to handle the simple cases. For more complicated cases, it's still possible to retain some benefits\r\nfrom jersey-wiremock by using an abstract class instead of an interface. All the annotated abstract methods work as\r\ndescribed above, but concrete methods may be provided to perform actions that jersey-wiremock doesn't support.\r\n\r\nAll such abstract classes must inherit from `BaseMocker`.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}